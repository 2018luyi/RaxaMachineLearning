package com.learningmodule.association.conceptdrug.learning;

import java.util.HashSet;
import java.util.Hashtable;
import java.util.LinkedList;

import com.learningmodule.association.conceptdrug.model.EncounterIdConceptDrug;
import com.learningmodule.association.conceptdrug.model.PredictionMatrix;

/*
 * Class for Apriori Algorithm designed specifically to find Diesease to Drug Association Rules.
 */

public class CustomApriori {

	// min support for association rules
	private double minSupport;
	private int minSupp;

	// minConfidence for association rules
	private double minConfidence;

	// associations rules generated by apriori algorithm
	private Hashtable<String, Row> rules;

	// constructor for this class
	public CustomApriori() {
		rules = new Hashtable<String, Row>();
	}

	// constructor for this class given minSupport and minConfidence
	public CustomApriori(int minSupport, double minConfidence) {
		this.minSupport = minSupport;
		this.minConfidence = minConfidence;
		rules = new Hashtable<String, Row>();
	}

	// function to increment count of a concept whenever a concepts is found
	// records
	private void incrementConceptCounts(HashSet<String> ids) {
		for (String id : ids) {
			rules.get(id).conceptCount++;
		}
	}

	public PredictionMatrix buildAssociations(LinkedList<EncounterIdConceptDrug> data) {

		// number of instances/records/unique encounterIds
		int noOfInstance = 0;

		// previous encounterId/recordId
		int preEncounterId = 0;

		// set of disgnosis/observations in current EncounterId
		HashSet<String> currentInstanceConcepts = new HashSet<String>();

		// for every row of records
		for (EncounterIdConceptDrug item : data) {

			// add the diagnosis/conceptId in rules if not already present
			if (!rules.containsKey(item.getConceptId())) {
				rules.put(item.getConceptId(), new Row(item.getConceptId()));
			}

			// add the drug to the rule with above conceptId
			rules.get(item.getConceptId()).addDrug(item.getDrug());

			// if the encouterId is different from previous one
			if (item.getEncounterId() != preEncounterId) {

				// increment the concept counts for all the concepts appeared
				// with previous encounterId
				incrementConceptCounts(currentInstanceConcepts);

				// clear the set of conceptIds as these are for previous
				// encounterId
				currentInstanceConcepts.clear();

				// increment number of instances/dignosis records
				noOfInstance++;

				// set previous encounterId to current encounterId
				preEncounterId = item.getEncounterId();
			}

			// add conceptId to the set of currentIds for current encounterId
			currentInstanceConcepts.add(item.getConceptId());
		}

		// number of concepts/diagnosis that will have association rules with
		// drugs
		int noOfConcepts = 0;

		// min support for diagnosis drug association rules
		minSupp = (int) minSupport * noOfInstance;
		// System.out.println(rules.contains("1"));

		// list of concepts to be removed if they have frequency more then 0.5
		// or there count is less the minSupport
		LinkedList<Row> conceptsToBeRemoved = new LinkedList<Row>();

		// for every rule in rules
		for (Row rule : rules.values()) {
			// remove concept if the count is greater the half the total numeber
			// of instances or count is less then min suppport
			if (rule.conceptCount > 0.5 * noOfInstance || rule.conceptCount < minSupp) {
				conceptsToBeRemoved.add(rule);
				noOfConcepts--;
			}
			noOfConcepts++;
		}
		for (Row rule : conceptsToBeRemoved) {
			rules.remove(rule);
		}

		// Predication Matrix output of the algorithm
		PredictionMatrix results = new PredictionMatrix(noOfConcepts);

		// for every conceptId in rules
		for (Row rule : rules.values()) {

			// for every drug related to conceptId
			for (Drug drug : rule.drugs) {

				// if the ratio of drugCount and conceptCount is greater then
				// min confidence add the conceptId to drug in prediction matrix
				double conf = ((double) drug.drugCount) / ((double) rule.conceptCount);
				if (drug.drugCount >= minSupp && conf >= minConfidence) {
					results.addCell(rule.concept, drug.drugId, conf);
				}
			}
		}
		System.out.println(minSupp + "," + noOfInstance);
		return results;
	}

	// class to represent rules for a conceptId
	private class Row {
		
		// conceptId
		public String concept;
		
		// concept count
		public int conceptCount;
		
		// list of Drug found with this concept
		public LinkedList<Drug> drugs;

		// constructor for this class
		public Row(String concept) {
			this.concept = concept;
			this.conceptCount = 0;
			drugs = new LinkedList<Drug>();
		}

		// method to add the drug for this concept
		public void addDrug(String drugId) {
			
			// search for drugId in the list of drugs for this concept.
			for (Drug drug : drugs) {
				
				// if drug is found increment the drug count.
				if (drug.drugId.equals(drugId)) {
					drug.incCount();
					return;
				}
			}
			
			// add the drug if not alread present
			drugs.add(new Drug(drugId));
		}
	}

	// class of nodes that represent drug in Class Row
	private class Drug {
		
		// drugId
		public String drugId;
		
		// drug count for the conceptId Row it belongs to
		public int drugCount;

		// constructor for drug
		public Drug(String drugId) {
			this.drugId = drugId;
			this.drugCount = 1;
		}

		// method to increment count
		public void incCount() {
			drugCount++;
		}
	}

	public double getMinSupport() {
		return minSupport;
	}

	public void setMinSupport(double minSupport) {
		this.minSupport = minSupport;
	}

	public double getMinConfidence() {
		return minConfidence;
	}

	public void setMinConfidence(double minConfidence) {
		this.minConfidence = minConfidence;
	}
}
